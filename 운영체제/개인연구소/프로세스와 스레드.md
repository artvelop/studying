 # 프로세스를 알아보자

 우선 프로세스의 간단한 정의는 '실행중인 프로그램'이다.

 프로그램을 메모리에 적재하여 운영체제의 제어를 받는 상대가 되면 프로세스이다.

    프로그램 : 정적인 데이터
    프로세스 : 동적인 개체

# 사용자 관점의 프로세스의 메모리 구조

    사용자 관점에서의 프로세스는 주소 공간을 가지고 실행하는 프로그램을 뜻한다.


![메모리 구조](./resource/memory_location.png)

## 코드 영역

+ 실행 할 프로그램의 코드가 저장되는 공간으로 CPU는 이 영역에 저장된 명령문을 가져간다
+ 읽기전용 이므로 프로그램이 코드영역을 침범하면 오류가 발생한다

## 데이터 영역

+ 데이터는 프로그램의 가상 주소 공간이다.
+ 전역변수와 static변수가 할당된다 
+ 이 영역에 할당되는 변수들은 시작과 동시에 메모리 공간에 할당되며 프로그램이 종료할 때 까지 남아있는다

## 스택 영역

+ 데이터를 일시적으로 저장하는 영역이다.
+ 지역변수와 매개변수가 할당된다
+ 이 영역에 할당된 변수는 선언된 위치의 함수를 빠져나갈 경우 소멸된다

## 힙 영역

+ 알고리즘을 짜다보면 프로그래머가 원하는 시점에 변수를 할당하고 해제하고 싶을 때가 있다(주로 malloc과 free를 사용할 때)
+ 이 경우에 변수가 할당되는 영역이 힙 영역이다
+ 동적메모리를 할당한다
+ 코드 영역과는 별도로 유지되는 자유 영역

# 시스템 관점에서의 프로세스

+ 역할로 분류

    + 시스템(커널)프로세스
            
            모든 시스템 메모리와 프로세서의 명령에 액세스 할 수 있는 프로그램
            사용자 프로세스를 생성하는 기능을 한다

    + 사용자 프로세스

            사용자 코드를 수행하는 프로세스

+ 병행 수행 방법으로 분류

    + 독립 프로세스

            다른 프로세스와 영향을 주고 받지 않는다.

    + 협력 프로세스

            다른 프로세스와 영향을 주고 받는다

# 프로세스의 상태 변화와 상태 정보

프로세스는 시스템에서 준비, 실행, 대기 상태로 바뀌면서 실행하고 종료하는데 시스템을 떠날 때까지 반복한다.

프로세스의 상태 변화는 운영체제가 작업 스케줄러와 프로세스 스케줄러 같은 프로세서 스케줄러를 이용하여 관리한다.

+ ## 작업 스케줄러

    + 스풀러가 디스크에 저장한 작업 중 실행할 작업을 선정하고 준비 리스트에 삽입하여 다중 프로그래밍의 정도를 결정한다.

+ ## 프로세서 스케줄러

    ![프로세스의 상태 변화](./resource/process_sche.jpg)

    1. 실행 상태의 프로세스가 프로세서를 자발적으로 반환하기 전에 할당된 시간이 지나면 이 프로세스는 준비 상태가 된다.

    2. 대기 상태의 프로세슨느 대기 원인을 제거하면 준비 상태로 바뀐다.

    3. 디스패처가 준비 상태인 프로세스에 프로세서를 할당하면 다시 실행 상태로 바뀐다.

+ ## 3번에 언급한 디스패처는 스케줄러가 선택한 프로세스에 프로세서를 할당하는 모듈이다.

    ![디스패처](./resource/dispatcher.png)

+ ## 프로세스의 상태 변화

    + 준비 -> 실행 : 디스패치(dispatch)

        + 준비 큐 맨 앞에 있던 프로세스가 프로세서를 점유하는것
        + 다중프로그래밍 운영체제에서는...
            + 실행 상태인 프로세스는 할당된 시간만큼만 사용한다
            + 이로써 특정프로세스가 프로세서를 독점하는걸 방지한다

    + 실행 -> 준비 : 타임아웃(timeout)

        + 운영체제는 실행 상태의 프로세스가 프로세서를 계속 독점하지 않도록 인터럽트 클록을 두어 특정 프로세스가 할당된 시간 동안만 프로세서를 점유하게 한다.
        + 타임아웃되어도(일정시간이 지남) 프로세서를 반환하지 않으면 클록이 인터럽트를 발생시켜 운영체제에 프로세서 제어권을 부여한다.
        + 그리하면 실행 프로세스는 준비 상태가 되고 준비 리스트의 첫번째 프로세스가 실행 상태가 된다.

    + 실행 -> 대기 : 블록(block)

        + 할당된 시간 이전에 실행 상태의 프로세스에 
            + 입출력 연산
            + 새로운 자원 요청
        + 등의 문제로 프로세서를 스스로 양도하면 대기상태가 된다.

    + 대기 -> 준비 : wakeup

        + 프로세스는 입출력 작업이 끝나면 깨움으로 대기에서 준비 상태가 된다.

+ ## 프로세스 제어 블록

     프로세스를 제어할 때 필요한 프로세스 상태 정보는 프로세스 제어 블록에 저장된다

     + 프로세스 제어 블록

        + 특정 프로세스 정보를 저장하는 데이터 블록이나 레코드
        + '작업 제어 블록' 이라고도 한다.

    + 프로세스가 생성되면 프로세스 제어블록을 생성하고,
    + 프로세스가 종료되면 해당 프로세스 제어블록도 삭제한다

    다음 그림은 프로세스 제어블록에 들어가는 정보들이다

    ![프로세스 제어 블록](./resource/process_control.png)

    영어로 되어 있어서 작성자가 알아보기 힘들다 

    근데 이거 교수님이 그냥 넘어가셔서 크게 자세하게 안봐도 된다.

+ ## 프로세스와 문맥 교환

    인터럽트와 시스템 호출 등으로
    
    실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것을
    
    문맥교환이라고 한다

    + 문맥교환이 일어나면...

            프로세서의 레지스터에 있던 내용을
            나중에 사용할 수 있도록 저장한다

    ![프로세스 문맥 교환](./resource/monmack.png)

# 프로세스의 구조

프로세스는 실행 중에 프로세스 생성 시스템 호출을 이용하여 새로운 프로세스를 생성할 수 있다.

이때 프로세스 생성 순서를 저장하고 부모-자식 관계를 유지하여 계층적으로 생성한다.

+ 부모 프로세스

    + 프로세스를 새로 생성하는 프로세스

+ 자식 프로세스, 서브 프로세스

    + 부모 프로세스한테 생성되는 프로세스

![프로세스 계층 구조](./resource/process_1.png)

[유닉스 시스템의 프로세스 계층 구조 예]

## 프로세스의 생성


우선 프로세스를 생성할 때 필요한 세부작업은 다음과 같다.

1. 새로운 프로세스에 프로세스 식별자를 할당한다
2. 프로세스의 모든 구성 요소를 포함할 수 있ㄴ느 주소 공간과 프로세스 제어 블록 공간을 할당한다
3. 프로세스 제어 블록을 초기화한다. 프로세스 상태, 프로그램 카운터 등 초기화, 자원 요청, 프로세스 제어 정보(우선순위) 등을 포함한다
4. 링크를 건다(해당 큐에 삽입한다)

프로세스가 작업을 수행하려면 프로세서 점유 시간, 메모리, 파일, 입출력장치 등 자원이 필요하다.

+ 자식프로세스

    + 운영체제에서 직접 필요한 자원을 얻거나 부모 프로세스의 자원을 일부 사용한다.

+ 부모 프로세스

    + 자식 프로세스가 사용하는 자원을 제한해서 특정 프로세스가 자식 프로세스를 너무 많이 생성하여 시스템에 부담주는 것을 막을 수 있다.

프로세스가 새로운 프로세스를 생서할 때 다음 두가지 실행이 발생할 수 있다.

+ 부모 프로세스와 자식 프로세스를 동시에 실행한다.

+ 부모 프로세스는 자식 프로세스를 모두 종료할 때까지 기다린다.

## 프로세스의 종료

프로세스가 마지막 명령을 실행하면 종료하여 운영체제에 프로세스의 삭제를 요청한다.

+ 일괄 처리 환경

    + 작업 종료를 의미하는 신호로 인터럽트를 발생시킴
    + 시스템 호출로 중단명령을 전달

+ 대화형 환경

    + 사용자가 로그오프함
    + 터미널을 닫으면 프로세스를 종료
    + 이외에도 오류로 프로세스 종료가능

_

    TIP
    abort 명령어로도 프로세스를 종료할 수 있는데,
    종료할 프로세스의 부모 프로세스만 호출한다.
    이는 다른 프로세스가 임의로 해당 프로세스를 중단할 수 없기 때문
    자식프로세스는 종료할 때 자신의 식별자를 부모에게 전달

+ 부모 프로세스는 다음 상황에서 자식 프로세스를 종료할 수 있다.

    + 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때

    + 자식 프로세스에 할당한 작업이 더는 없을 때

+  프로세스가 종료하는 이유는 다음과 같다

    + 정상 종료 : 프로세스가 운영체제의 서비스를 호출할 때

    + 시간 초과 : 프로세스가 명시된 시간을 초과하여 이벤트가 발생할 때

    + 실패 : 파일 검색 실패, 입출력이 명시된 횟수 초과하여 실패할 때

    + 산술 오류, 보호 오류, 데이터 오류 등

    + 메모리 부족, 액세스 위반


## 프로세스의 중단과 재시작

다중 프로그래밍에서 중단은 자원부족(대기) 상태를 의미한다.

여기서 중단된 프로세스는 기다리던 이벤트가 발생하면 중단 이전의 상태로 돌아갈 수 있는데,

여기서 프로세스를 중단한 원인을 제거하여 다시 실행하는 것을 재시작이라고 한다.

+ 프로세스 중단과 재시작은 시스템 부하를 조절하는데 상당히 중요하고, 다음 상황에서 주로 사용한다.

    + 시스템에 장애가 발생하면 실행 중인 프로세스는 잠시 중단했다가 시스템이 기능을 회복했을 때 다시 재시작할 수 있다.

    + 프로세스에 의심스러운 부분이 있으면 실행 중인 프로세스를 중단하여 확인한 후 재시작하여 종료할 수 있다.

    + 처리할 작업이 너무 많아 시스템에 부담이 되면 프로세스 몇 개를 중단했다가 시스템이 정상 상태로 다시 돌아왔을 때 재시작할 수 있다.

![프로세스 상태 변화](./resource/process_state.jpg)

    TIP
    중단은 매우 중요한 작업이다.
    보통 짧은 시간에 많은 프로세스를 요청하면 프로세스 몇개가 중단된다.
    장신간 중단할 떄는 해당프로세스에 할당된 자원을 다시 돌려줘야하는데
    자우너의 성질에 따라서 돌려줄 자원을 결정한다.

    메인메모리
    + 프로세서를 중단하자마자 돌려준다

    보조 메모리
    + 중단시간을 예측불가능하거나 너무 길때 돌려주어야한다

    중단된 대기 상태
    + 프로세스가 보조 메모리에 있고 이벤트를 대기중인 상태

    중단된 준비 상태
    + 프로세스가 보조 메모리에 있지만 즉시 메인메모리로 적재하여 실행할수 있는 상태

## 프로세스의 우선순위 변경

프로세스 스케줄러는 프로세스 제어 블록에 있는 우선순위를 이용하여 준비 리스트의 프로세스를 처리한다.

준비리스트의 프로세스는 프로세서 중심 프로세스와 입출력 중심 프로세스로 구분할 수 있다.

+ 입출력 중심 프로세스는...

        속도가 느리면서 빠른 응답을
        요구하는 단말기 입출력 프로세스에 높은 우선순위를 부여한다

+ 속도가 빠른 디스크 입출력 프로세스는...

        위의 프로세스에 낮은 우선순위를 부여한다.

이 때 우선순위가 낮은 프로세스에 시간을 많이 할당하고,

우선순위가 높은 프로세스에는 시간을 적게 할당한다.

## 프로세스의 문맥 교환

보통 인터럽트가 발생하면 인터럽트 처리 루틴으로 제어가 넘어간 후에 시스템 관리와 관련된 기본 작업을 하고는 인터렙트 유형에 따라 관련 루틴으로 분기한다.

+ 입출력 인터럽트

    + 입출력 동작이 발생했음을 확인하고 이벤트를 기다리는 프로세스를 준비 상태로 바꾼 후 실행할 프로세스를 결정한다.

+ 클록 인터럽트

    + 현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비 상태로 바꾸고, 다른 프로세스를 실행 상태로 바꾼다.

실행 중인 프로세스에 인터럽트가 발생하면 운영체제가 다른 프로세스를 실행 상태로 바꾸고 제어를 넘겨주어 프로세스 문맥교환이 발생한다.
![프로세스 문맥 교환](./resource/process_bargain.jpg)

